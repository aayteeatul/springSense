## This code uses data extracted from the Phyphox app (https://phyphox.org/), but any app or alternative method for recording acceleration data can be used.

import pandas as pd
import numpy as np
from scipy.fft import fft, fftfreq
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# ==========================================
# 1. CONFIGURATION SECTION (EDIT THIS)
# ==========================================
FILENAME = 'AN10_2.csv'

# Mass properties
SPRING_MASS_GRAMS = 4.64  # Mass of the spring itself (change this after measuring the spring mass)
ATTACHED_MASS_GRAMS = 0.5  # Mass of the phone/weight attached (0 if just the spring)

# Damping Ratio (Zeta) estimate
# 0.3 is quite high (like a shock absorber).
# A bare metal spring usually has very low damping (0.001 - 0.05).
ZETA = 0.3

# ==========================================
# 2. DATA PROCESSING
# ==========================================

# Calculate Effective Mass in kg
# Theory: For a spring with mass, m_eff â‰ˆ M_attached + (1/3 * M_spring)
m_eff_kg = (ATTACHED_MASS_GRAMS + (SPRING_MASS_GRAMS / 3.0)) / 1000.0

print(f"--- Configuration ---")
print(f"Spring Mass: {SPRING_MASS_GRAMS} g")
print(f"Attached Mass: {ATTACHED_MASS_GRAMS} g")
print(f"Effective Mass used for calculation: {m_eff_kg:.4f} kg")
print(f"Assumed Damping Ratio (Zeta): {ZETA}")
print(f"---------------------\n")

try:
    df = pd.read_csv(FILENAME)
except FileNotFoundError:
    print("File not found. Using dummy data for demonstration.")
    # Dummy data generator so code runs if you copy-paste without a file
    t = np.linspace(0, 5, 500)
    # Simulating a 20Hz vibration with decay
    accel = np.exp(-2*t) * np.sin(2 * np.pi * 20 * t)
    df = pd.DataFrame({'Time (s)': t, 'Linear Acceleration z (m/s^2)': accel})

# Clean column names
df.columns = [c.strip() for c in df.columns]

# Trim first 1.0 second
df_trimmed = df[df['Time (s)'] > 1.0].copy()

if df_trimmed.empty:
    print("Error: No data left after trimming.")
else:
    df_trimmed.reset_index(drop=True, inplace=True)

    # Calculate Sampling Rate
    time_diff = df_trimmed['Time (s)'].diff().mean()
    fs = 1.0 / time_diff

    # FFT Function
    def get_spectrum_and_stiffness(signal, fs, mass_kg, zeta):
        # 1. FFT Processing
        signal_centered = signal - np.mean(signal)
        n = len(signal)
        n_padded = max(n, 4096) # High padding for better freq resolution

        yf = fft(signal_centered.values, n=n_padded)
        xf = fftfreq(n_padded, 1 / fs)

        positive_freqs = xf[:n_padded//2]
        amplitudes = np.abs(yf[:n_padded//2])

        # 2. Find Peak Frequency (Damped Frequency f_d)
        peak_idx = np.argmax(amplitudes)
        f_d = positive_freqs[peak_idx] # Hz

        # 3. Calculate Stiffness
        if f_d > 0:
            # Convert Hz to rad/s
            omega_d = 2 * np.pi * f_d

            # Calculate Undamped Natural Frequency (omega_n)
            # omega_d = omega_n * sqrt(1 - zeta^2)
            if zeta < 1.0:
                omega_n = omega_d / np.sqrt(1 - zeta**2)
            else:
                omega_n = omega_d # Overdamped fallback

            # Calculate Stiffness k = m * omega_n^2
            k = mass_kg * (omega_n**2)
        else:
            k = 0.0

        return f_d, k, positive_freqs, amplitudes

    # Setup Plot
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=False,
        vertical_spacing=0.15,
        subplot_titles=("Time Domain", "Frequency Domain")
    )

    # Match these axis names with your data header
    axes_map = {
        'x': 'Linear Acceleration x (m/s^2)',
        'y': 'Linear Acceleration y (m/s^2)',
        'z': 'Linear Acceleration z (m/s^2)'
    }
    colors = {'x': 'red', 'y': 'green', 'z': 'blue'}

    print("--- Results ---")

    for axis_name, col_name in axes_map.items():
        if col_name in df_trimmed.columns:
            # Check if axis has significant data (noise check)
            if df_trimmed[col_name].std() < 0.01:
                continue # Skip axes with no real movement

            peak_f, k_est, freq_x, amp_y = get_spectrum_and_stiffness(
                df_trimmed[col_name], fs, m_eff_kg, ZETA
            )

            print(f"Axis {axis_name.upper()} | Freq: {peak_f:.2f} Hz | Est. Stiffness (k): {k_est:.2f} N/m")

            # Time Plot
            fig.add_trace(go.Scatter(x=df_trimmed['Time (s)'], y=df_trimmed[col_name],
                           name=f'{axis_name} (Time)', line=dict(color=colors[axis_name], width=1)), row=1, col=1)

            # Freq Plot
            fig.add_trace(go.Scatter(x=freq_x, y=amp_y,
                           name=f'{axis_name} (Freq)', line=dict(color=colors[axis_name]),
                           hovertemplate='Freq: %{x:.2f} Hz<br>Amp: %{y:.2f}'), row=2, col=1)

    fig.update_layout(title="Stiffness Estimator", height=700, hovermode="x unified")
    fig.update_xaxes(title="Frequency (Hz)", row=2, col=1, range=[0, fs/2])
    fig.show()
